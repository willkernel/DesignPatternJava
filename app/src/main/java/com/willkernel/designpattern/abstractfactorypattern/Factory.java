package com.willkernel.designpattern.abstractfactorypattern;

/**
 * 产品等级结构： 产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
 * <p>
 * 产品族： 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
 * <p>
 * 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。
 * <p>
 * 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。
 * <p>
 * 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，
 * 一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。
 * 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率
 * <p>
 * <p>
 * 抽象工厂模式优缺点
 * 优点
 * ①抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。
 * 所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
 * 另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
 * <p>
 * ②增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。
 * <p>
 * 缺点
 * 在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，
 * 这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，
 * 而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
 * <p>
 * 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。
 * <p>
 * 适用环境
 * 在以下情况下可以使用抽象工厂模式：
 * <p>
 * ①一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
 * <p>
 * ②系统中有多于一个的产品族，而每次只使用其中某一产品族。与工厂方法模式的区别
 * <p>
 * ③属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
 * <p>
 * ④系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
 */
public interface Factory {
    Apple createAppleProduct();

    Samsung createSamsungProduct();
}
